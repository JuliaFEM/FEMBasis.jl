<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Introduction · FEMBasis.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>FEMBasis.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li class="current"><a class="toctext" href="index.html">Introduction</a><ul class="internal"></ul></li><li><a class="toctext" href="api.html">API documentation</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href="index.html">Introduction</a></li></ul><a class="edit-page" href="https://github.com/JuliaFEM/FEMBasis.jl/blob/master/docs/src/index.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Introduction</span><a class="fa fa-bars" href="#"></a></div></header><p><a href="https://travis-ci.org/JuliaFEM/FEMBasis.jl"><img src="https://travis-ci.org/JuliaFEM/FEMBasis.jl.svg?branch=master" alt="Build Status"/></a><a href="https://coveralls.io/github/JuliaFEM/FEMBasis.jl?branch=master"><img src="https://coveralls.io/repos/github/JuliaFEM/FEMBasis.jl/badge.svg?branch=master" alt="Coverage Status"/></a><a href="https://juliafem.github.io/FEMBasis.jl/stable"><img src="https://img.shields.io/badge/docs-stable-blue.svg" alt/></a><a href="https://juliafem.github.io/FEMBasis.jl/latest"><img src="https://img.shields.io/badge/docs-latest-blue.svg" alt/></a><a href="https://github.com/JuliaFEM/FEMBasis.jl/issues"><img src="https://img.shields.io/github/issues/JuliaFEM/FEMBasis.jl.svg" alt="Issues"/></a></p><p><code>FEMBasis.jl</code> contains interpolation routines for standard finite element function spaces.  Given ansatz and coordinates of domain, interpolation functions are calculated  symbolically in a very general way to get efficient code. As a concrete example, to generate basis functions for a standard 10-node tetrahedron one can write</p><pre><code class="language-julia">code = create_basis(
    :Tet10,
    &quot;10 node quadratic tetrahedral element&quot;,
    (
     (0.0, 0.0, 0.0), # N1
     (1.0, 0.0, 0.0), # N2
     (0.0, 1.0, 0.0), # N3
     (0.0, 0.0, 1.0), # N4
     (0.5, 0.0, 0.0), # N5
     (0.5, 0.5, 0.0), # N6
     (0.0, 0.5, 0.0), # N7
     (0.0, 0.0, 0.5), # N8
     (0.5, 0.0, 0.5), # N9
     (0.0, 0.5, 0.5), # N10
    ),
    &quot;1 + u + v + w + u*v + v*w + w*u + u^2 + v^2 + w^2&quot;,
   )</code></pre><p>The resulting code is</p><pre><code class="language-julia">begin
    mutable struct Tet10
    end
    function Base.size(::Type{Tet10})
        return (3, 10)
    end
    function Base.size(::Type{Tet10}, j::Int)
        j == 1 &amp;&amp; return 3
        j == 2 &amp;&amp; return 10
    end
    function Base.length(::Type{Tet10})
        return 10
    end
    function FEMBasis.get_reference_element_coordinates(::Type{Tet10})
        return ((0.0, 0.0, 0.0), (1.0, 0.0, 0.0), (0.0, 1.0, 0.0), (0.0, 0.0, 1.0), (0.5, 0.0, 0.0), (0.5, 0.5, 0.0), (0.0, 0.5, 0.0), (0.0, 0.0, 0.5), (0.5, 0.0, 0.5), (0.0, 0.5, 0.5))
    end
    function FEMBasis.eval_basis!{T}(::Type{Tet10}, N::Matrix{T}, xi::Tuple{T, T, T})
        (u, v, w) = xi
        begin
            N[1] = 1.0 + -3.0u + -3.0v + -3.0w + 4.0 * (u * v) + 4.0 * (v * w) + 4.0 * (w * u) + 2.0 * u ^ 2 + 2.0 * v ^ 2 + 2.0 * w ^ 2
            N[2] = -u + 2.0 * u ^ 2
            N[3] = -v + 2.0 * v ^ 2
            N[4] = -w + 2.0 * w ^ 2
            N[5] = 4.0u + -4.0 * (u * v) + -4.0 * (w * u) + -4.0 * u ^ 2
            N[6] = +(4.0 * (u * v))
            N[7] = 4.0v + -4.0 * (u * v) + -4.0 * (v * w) + -4.0 * v ^ 2
            N[8] = 4.0w + -4.0 * (v * w) + -4.0 * (w * u) + -4.0 * w ^ 2
            N[9] = +(4.0 * (w * u))
            N[10] = +(4.0 * (v * w))
        end
        return N
    end
    function FEMBasis.eval_dbasis!{T}(::Type{Tet10}, dN::Matrix{T}, xi::Tuple{T, T, T})
        (u, v, w) = xi
        begin
            dN[1, 1] = -3.0 + 4.0v + 4.0w + 2.0 * (2u)
            dN[2, 1] = -3.0 + 4.0u + 4.0w + 2.0 * (2v)
            dN[3, 1] = -3.0 + 4.0v + 4.0u + 2.0 * (2w)
            dN[1, 2] = -1 + 2.0 * (2u)
            dN[2, 2] = 0
            dN[3, 2] = 0
            dN[1, 3] = 0
            dN[2, 3] = -1 + 2.0 * (2v)
            dN[3, 3] = 0
            dN[1, 4] = 0
            dN[2, 4] = 0
            dN[3, 4] = -1 + 2.0 * (2w)
            dN[1, 5] = 4.0 + -4.0v + -4.0w + -4.0 * (2u)
            dN[2, 5] = -4.0u
            dN[3, 5] = -4.0u
            dN[1, 6] = 4.0v
            dN[2, 6] = 4.0u
            dN[3, 6] = 0
            dN[1, 7] = -4.0v
            dN[2, 7] = 4.0 + -4.0u + -4.0w + -4.0 * (2v)
            dN[3, 7] = -4.0v
            dN[1, 8] = -4.0w
            dN[2, 8] = -4.0w
            dN[3, 8] = 4.0 + -4.0v + -4.0u + -4.0 * (2w)
            dN[1, 9] = 4.0w
            dN[2, 9] = 0
            dN[3, 9] = 4.0u
            dN[1, 10] = 0
            dN[2, 10] = 4.0w
            dN[3, 10] = 4.0v
        end
        return dN
    end
end</code></pre><p>Also more unusual elements can be defined. For example, pyramid element cannot be descibed with ansatz, but it&#39;s still possible to implement by defining shape functions, <code>Calculus.jl</code> is taking care of defining partial derivatives of function:</p><pre><code class="language-julia">code = create_basis(
    :Pyr5,
    &quot;5 node linear pyramid element&quot;,
    (
     (-1.0, -1.0, -1.0), # N1
     ( 1.0, -1.0, -1.0), # N2
     ( 1.0,  1.0, -1.0), # N3
     (-1.0,  1.0, -1.0), # N4
     ( 0.0,  0.0,  1.0), # N5
    ),
    (
     &quot;1/8 * (1-u) * (1-v) * (1-w)&quot;,
     &quot;1/8 * (1+u) * (1-v) * (1-w)&quot;,
     &quot;1/8 * (1+u) * (1+v) * (1-w)&quot;,
     &quot;1/8 * (1-u) * (1+v) * (1-w)&quot;,
     &quot;1/2 * (1+w)&quot;,
    ),
   )
eval(code)</code></pre><p>Basis function can have internal variables if needed, e.g. variable dof basis like hierarchical basis functions or NURBS.</p><p>It&#39;s also possible to do some very common FEM calculations, like calculate Jacobian or gradient of some variable with respect to some coordinates. For example, to  calculate displacement gradient du/dX in unit square [0,1]^2, one could write:</p><pre><code class="language-julia">B = Quad4()
X = ([0.0, 0.0], [1.0, 0.0], [1.0, 1.0], [0.0, 1.0])
u = ([0.0, 0.0], [1.0, -1.0], [2.0, 3.0], [0.0, 0.0])
grad(B, u, X, (0.0, 0.0))</code></pre><p>Result is</p><pre><code class="language-julia">2×2 Array{Float64,2}:
 1.5  0.5
 1.0  2.0</code></pre><footer><hr/><a class="next" href="api.html"><span class="direction">Next</span><span class="title">API documentation</span></a></footer></article></body></html>
